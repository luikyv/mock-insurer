//go:build go1.22

// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package v2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-insurer/internal/api"
	"github.com/luikyv/mock-insurer/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for ResponseResourceListDataStatus.
const (
	AVAILABLE              ResponseResourceListDataStatus = "AVAILABLE"
	PENDINGAUTHORISATION   ResponseResourceListDataStatus = "PENDING_AUTHORISATION"
	TEMPORARILYUNAVAILABLE ResponseResourceListDataStatus = "TEMPORARILY_UNAVAILABLE"
	UNAVAILABLE            ResponseResourceListDataStatus = "UNAVAILABLE"
)

// Defines values for ResponseResourceListDataType.
const (
	CAPITALIZATIONTITLES                        ResponseResourceListDataType = "CAPITALIZATION_TITLES"
	CUSTOMERSBUSINESSADDITIONALINFO             ResponseResourceListDataType = "CUSTOMERS_BUSINESS_ADDITIONALINFO"
	CUSTOMERSBUSINESSIDENTIFICATIONS            ResponseResourceListDataType = "CUSTOMERS_BUSINESS_IDENTIFICATIONS"
	CUSTOMERSBUSINESSQUALIFICATION              ResponseResourceListDataType = "CUSTOMERS_BUSINESS_QUALIFICATION"
	CUSTOMERSPERSONALADDITIONALINFO             ResponseResourceListDataType = "CUSTOMERS_PERSONAL_ADDITIONALINFO"
	CUSTOMERSPERSONALIDENTIFICATIONS            ResponseResourceListDataType = "CUSTOMERS_PERSONAL_IDENTIFICATIONS"
	CUSTOMERSPERSONALQUALIFICATION              ResponseResourceListDataType = "CUSTOMERS_PERSONAL_QUALIFICATION"
	DAMAGESANDPEOPLEACCEPTANCEANDBRANCHESABROAD ResponseResourceListDataType = "DAMAGES_AND_PEOPLE_ACCEPTANCE_AND_BRANCHES_ABROAD"
	DAMAGESANDPEOPLEAUTO                        ResponseResourceListDataType = "DAMAGES_AND_PEOPLE_AUTO"
	DAMAGESANDPEOPLEFINANCIALRISKS              ResponseResourceListDataType = "DAMAGES_AND_PEOPLE_FINANCIAL_RISKS"
	DAMAGESANDPEOPLEHOUSING                     ResponseResourceListDataType = "DAMAGES_AND_PEOPLE_HOUSING"
	DAMAGESANDPEOPLEPATRIMONIAL                 ResponseResourceListDataType = "DAMAGES_AND_PEOPLE_PATRIMONIAL"
	DAMAGESANDPEOPLEPERSON                      ResponseResourceListDataType = "DAMAGES_AND_PEOPLE_PERSON"
	DAMAGESANDPEOPLERESPONSIBILITY              ResponseResourceListDataType = "DAMAGES_AND_PEOPLE_RESPONSIBILITY"
	DAMAGESANDPEOPLERURAL                       ResponseResourceListDataType = "DAMAGES_AND_PEOPLE_RURAL"
	DAMAGESANDPEOPLETRANSPORT                   ResponseResourceListDataType = "DAMAGES_AND_PEOPLE_TRANSPORT"
	FINANCIALASSISTANCE                         ResponseResourceListDataType = "FINANCIAL_ASSISTANCE"
	LIFEPENSION                                 ResponseResourceListDataType = "LIFE_PENSION"
	PENSIONPLAN                                 ResponseResourceListDataType = "PENSION_PLAN"
)

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// RequestDateTime Data e hora da consulta, conforme especificação RFC-3339, formato UTC.
		RequestDateTime timeutil.DateTime `json:"requestDateTime"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseResourceList defines model for ResponseResourceList.
type ResponseResourceList struct {
	// Data Lista de recursos e seus respectivos status.
	Data []struct {
		// ResourceID Identifica o recurso reportado pelo participante do Open Insurance, no caso de:
		// Produtos de Titulos de Capitalização: policyNumber ou certificateNumber
		// Produtos de Previdência: certificateNumber
		// Produtos de Danos e Pessoas (independente do ramo e torná-lo como obrigatório): policyNumber ou certificateNumber
		ResourceID string `json:"resourceId"`

		// Status - Tipo de status de recurso (vide Enum):
		// - Available: Disponível
		// - Unavailable: Indisponível
		// - Temporarily Unavailable: Temporariamente Indisponível
		// - Pending Authorisation: Pendente de Autorização
		Status ResponseResourceListDataStatus `json:"status"`

		// Type Tipo de recurso (vide Enum):
		// - CUSTOMERS_PERSONAL_IDENTIFICATIONS: Informações de identificação PF
		// - CUSTOMERS_PERSONAL_QUALIFICATION: Informações de qualificação PF
		// - CUSTOMERS_PERSONAL_ADDITIONALINFO: Informações complementares PF
		// - CUSTOMERS_BUSINESS_IDENTIFICATIONS: Informações de identificação PJ
		// - CUSTOMERS_BUSINESS_QUALIFICATION: Informações de qualificação PJ
		// - CUSTOMERS_BUSINESS_ADDITIONALINFO: Informações complementares PJ
		// - CAPITALIZATION_TITLES: Produtos de Titulos de Capitalização
		// - PENSION_PLAN: Produtos de Previdência Risco
		// - LIFE_PENSION: Produtos de Previdência Sobrevivência
		// - FINANCIAL_ASSISTANCE: Produtos de Assistência Financeira
		// - DAMAGES_AND_PEOPLE_PATRIMONIAL: Produtos de Patrimonial
		// - DAMAGES_AND_PEOPLE_RESPONSIBILITY: Produtos de Responsabilidade
		// - DAMAGES_AND_PEOPLE_TRANSPORT: Produtos de Transportes
		// - DAMAGES_AND_PEOPLE_FINANCIAL_RISKS: Produtos de Riscos Financeiros
		// - DAMAGES_AND_PEOPLE_RURAL: Produtos de Rural
		// - DAMAGES_AND_PEOPLE_AUTO: Produtos de Automóveis
		// - DAMAGES_AND_PEOPLE_HOUSING: Produtos de Habitacional
		// - DAMAGES_AND_PEOPLE_PERSON: Produtos de Pessoas (Repartição simples)
		// - DAMAGES_AND_PEOPLE_ACCEPTANCE_AND_BRANCHES_ABROAD: Aceitação e Sucursal no exterior
		Type ResponseResourceListDataType `json:"type"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseResourceListDataStatus - Tipo de status de recurso (vide Enum):
// - Available: Disponível
// - Unavailable: Indisponível
// - Temporarily Unavailable: Temporariamente Indisponível
// - Pending Authorisation: Pendente de Autorização
type ResponseResourceListDataStatus string

// ResponseResourceListDataType Tipo de recurso (vide Enum):
// - CUSTOMERS_PERSONAL_IDENTIFICATIONS: Informações de identificação PF
// - CUSTOMERS_PERSONAL_QUALIFICATION: Informações de qualificação PF
// - CUSTOMERS_PERSONAL_ADDITIONALINFO: Informações complementares PF
// - CUSTOMERS_BUSINESS_IDENTIFICATIONS: Informações de identificação PJ
// - CUSTOMERS_BUSINESS_QUALIFICATION: Informações de qualificação PJ
// - CUSTOMERS_BUSINESS_ADDITIONALINFO: Informações complementares PJ
// - CAPITALIZATION_TITLES: Produtos de Titulos de Capitalização
// - PENSION_PLAN: Produtos de Previdência Risco
// - LIFE_PENSION: Produtos de Previdência Sobrevivência
// - FINANCIAL_ASSISTANCE: Produtos de Assistência Financeira
// - DAMAGES_AND_PEOPLE_PATRIMONIAL: Produtos de Patrimonial
// - DAMAGES_AND_PEOPLE_RESPONSIBILITY: Produtos de Responsabilidade
// - DAMAGES_AND_PEOPLE_TRANSPORT: Produtos de Transportes
// - DAMAGES_AND_PEOPLE_FINANCIAL_RISKS: Produtos de Riscos Financeiros
// - DAMAGES_AND_PEOPLE_RURAL: Produtos de Rural
// - DAMAGES_AND_PEOPLE_AUTO: Produtos de Automóveis
// - DAMAGES_AND_PEOPLE_HOUSING: Produtos de Habitacional
// - DAMAGES_AND_PEOPLE_PERSON: Produtos de Pessoas (Repartição simples)
// - DAMAGES_AND_PEOPLE_ACCEPTANCE_AND_BRANCHES_ABROAD: Aceitação e Sucursal no exterior
type ResponseResourceListDataType string

// Authorization defines model for Authorization.
type Authorization = string

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// XMinV defines model for x-min-v.
type XMinV = string

// XVHeader defines model for x-v.
type XVHeader = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = string

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// Default defines model for Default.
type Default = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// OKResponseResourceList defines model for OKResponseResourceList.
type OKResponseResourceList = ResponseResourceList

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ResponseError

// ResourcesGetResourcesParams defines parameters for ResourcesGetResources.
type ResourcesGetResourcesParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve "reproduzir" esse valor no cabeçalho de resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XVHeader Versão do endpoint da API requisitado pelo cliente. O titular dos dados deve
	// responder com a versão mais alta suportada entre x-min-v e x-v. Se o valor de
	// x-min-v for igual ou maior que o valor de x-v, o cabeçalho x-min-v deve ser
	// tratado como ausente. Se todas as versões solicitadas não forem suportadas,
	// o titular dos dados deve responder com o código de status 406 Not Acceptable.
	XVHeader *XVHeader `json:"x-v,omitempty"`

	// XMinV Versão mínima do endpoint da API requisitado pelo cliente. O detentor dos dados
	// deve responder com a versão mais alta suportada entre x-min-v e x-v. Se todas as
	// versões solicitadas não forem suportadas, o titular dos dados deve responder com
	// um código de status 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém a lista de recursos consentidos pelo cliente.
	// (GET /resources)
	ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ResourcesGetResources operation middleware
func (siw *ServerInterfaceWrapper) ResourcesGetResources(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "resources"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ResourcesGetResourcesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XVHeader XVHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-v", valueList[0], &XVHeader, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-v", Err: err})
			return
		}

		params.XVHeader = &XVHeader

	}

	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV XMinV
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-min-v", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-min-v", valueList[0], &XMinV, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-min-v", Err: err})
			return
		}

		params.XMinV = &XMinV

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResourcesGetResources(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/resources", wrapper.ResourcesGetResources)

	return m
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type DefaultApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type OKResponseResourceListJSONResponse ResponseResourceList

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityApplicationJSONCharsetUTF8Response ResponseError

type ResourcesGetResourcesRequestObject struct {
	Params ResourcesGetResourcesParams
}

type ResourcesGetResourcesResponseObject interface {
	VisitResourcesGetResourcesResponse(w http.ResponseWriter) error
}

type ResourcesGetResources200JSONResponse struct {
	OKResponseResourceListJSONResponse
}

func (response ResourcesGetResources200JSONResponse) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources400ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources401ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources403ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources404ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources405ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources406ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources422ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources429ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources500ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém a lista de recursos consentidos pelo cliente.
	// (GET /resources)
	ResourcesGetResources(ctx context.Context, request ResourcesGetResourcesRequestObject) (ResourcesGetResourcesResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// ResourcesGetResources operation middleware
func (sh *strictHandler) ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams) {
	var request ResourcesGetResourcesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ResourcesGetResources(ctx, request.(ResourcesGetResourcesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ResourcesGetResources")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ResourcesGetResourcesResponseObject); ok {
		if err := validResponse.VisitResourcesGetResourcesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"RZdcuD27/b8AAAD//9n390lmOAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
